<html>
<meta charset='utf-8'>
<head>
    <script src='https://d3js.org/d3.v7.min.js'></script>
    <style>
        .gridlines .domain {
            stroke: none;
        }

        #svg9 {
            left: 250;
            position: absolute;
        }
    </style>
</head>
<body>
    <div id='plot1'></div>
    <br>
    <div id='plot2'></div>
    <br>
    <div id='plot3'></div>
    <br>
    <div id='plot4'></div>
    <br>
    <div id='plot5'></div>
    <br>
    <div id='plot6'></div>
    <br>
    <div id='plot7'></div>
    <br>
    <div id='plot8'></div>
    <br>
    <div id='plot10'></div>
    <br>
    <div id='plot9'></div>

    <script>
        let plot1Div = d3.select('#plot1');
        let plot2Div = d3.select('#plot2');
        let plot3Div = d3.select('#plot3');
        let plot4Div = d3.select('#plot4');
        let plot5Div = d3.select('#plot5');
        let plot6Div = d3.select('#plot6');
        let plot7Div = d3.select('#plot7');
        let plot8Div = d3.select('#plot8');
        let plot10Div = d3.select('#plot10');
        let plot9Div = d3.select('#plot9');
        let file = 'mammals.csv';
        let plotWidth = 600;
        let plotHeight = 600;
        let circleRadius = 5;
        let circleOpacity = 0.7;

        let lollipopPlotWidth = 700;
        let lollipopPlotHeight = 700;

        // =================================================================================================
        // #################### Double bar Chart dreams vs Non Dreaming
        //==================================================================================================
        // Function in called in the .then()

        // Plot 8 horizontal bar chart
        const render = data => {

        const margin = {left: 500, right: 10, top: 60, bottom: 10}
        const innerWidth = plotWidth - margin.left-margin.right;
        const innerHeight = plotHeight - margin.top-margin.bottom;
        const dreamRange = d3.extent( data, d => d.dreaming);
        const nonDreamRange = d3.extent( data, d => d.non_dreaming);
        const dreamScale = d3.scaleLinear().domain([0, dreamRange[1]]).range([50, 200]);
        const nonDreamScale = d3.scaleLinear().domain([0, nonDreamRange[1]]).range([50, 200]);
        const yScale = d3.scaleBand().domain(data.map(d => d.species)).range([0, innerHeight])

        const svg8 = plot8Div.append('svg')
                            .attr('width', 750)
                            .attr('height', plotHeight)
                          //  .style('border', '1px solid black')
        const chartArea8 = svg8.append('g')
            .attr('transform', `translate(${margin.left}, ${margin.top})`);

            // left bar chart
            chartArea8.selectAll("rect.left").data(data)
                .enter().append("rect")
                .attr('transform', `translate(${margin.left - 650})`)
                .attr("x", d => ( - nonDreamScale(d.non_dreaming)))
                .attr('y', d => yScale(d.species))
                .attr("class", "left")
                .attr('width', d => (nonDreamScale(d.non_dreaming)))
                .attr('height', yScale.bandwidth())
                .attr("stroke-width", "1")
                .attr("stroke", "black")
                .style("fill", "green")

            // Left Rectangle values
            chartArea8.selectAll("text.leftscore")
                .data(data)
                .enter().append("text")
                .attr("x",  d => (-nonDreamScale(d.non_dreaming) - 30))
                .attr("y", d => yScale(d.species))
                .attr("dx", "-132")
                .attr("dy", ".96em")
                .attr('font-size', '10px')
                .attr("text-anchor", "middle")
                .attr('class', 'leftscore')
                .attr('font-family', 'arial')
                .text(d => d['non_dreaming']);

                // right bar chart
            chartArea8.selectAll("rect.right").data(data)
                .enter().append("rect")
                .attr('y', d => yScale(d.species))
                .attr("class", "right")
                .attr('width', d =>  dreamScale(d.dreaming))
                .attr('height', yScale.bandwidth())
                .style("fill", "red")
                .attr('text-anchor', 'middle')
                .attr("stroke-width", "1")
                .attr("stroke", "black")

            //right Rectangle values
            chartArea8.selectAll("text.rightscore")
                .data(data)
                .enter().append("text")
                .attr("x",  d => (dreamScale(d.dreaming) +20))
                .attr("y", d => yScale(d.species))
                .attr("dx", -16)
                .attr("dy", ".96em")
                .attr("text-anchor", "center")
                .attr('font-family', 'arial')
                .attr('font-size', '10px')
                .attr('class', 'rightscore')
                .text(d => d['dreaming']);

            // Dreaming Label
            chartArea8.append("text")
                .attr("x", 78)
                .attr("y", -11)
                .attr("class","title").text("Dreaming(hours)")
                .attr('text-anchor', 'middle')
                .attr('dominant-baseline', 'middle')
                .attr('font-size', '20px')
                .attr('fill', 'black')
                .attr('font-weight', 'bold')
                .attr('font-family', 'arial');

            // Non-Dreaming Label
            chartArea8.append("text")
                .attr("x",-250)
                .attr("y", -11)
                .attr("class","title").text("Non-Dreaming(hours)")
                .attr('text-anchor', 'middle')
                .attr('dominant-baseline', 'middle')
                .attr('font-size', '20px')
                .attr('fill', 'black')
                .attr('font-weight', 'bold')
                .attr('font-family', 'arial');

            // Chart titles and labels
            chartArea8.append("text").attr("x",-120).attr("y", -40)
                .attr("class","title").text("Dreaming vs Non-Dreaming Pattern in Mammals ")
                .attr('text-anchor', 'middle')
                .attr('dominant-baseline', 'middle')
                .attr('font-size', '30px')
                .attr('fill', 'black')
                .attr('font-weight', 'bold')
                .attr('font-family', 'arial');

            // Cleaned species' names to make the plot more legible
            let species = [...new Set(data.map( d => d.species ))];

            let cleanedSpecies = ['African Giant Pouched Rat', 'Asian Elephant', 'Baboon',
                                'Big Brown Bat', 'Brazilian Tapir', 'Cat', 'Chimpanzee',
                                'Chinchilla', 'Cow', 'Eastern American Mole', 'Echidna',
                                'European Hedgehog', 'Galago', 'Goat', 'Golden Hamster',
                                'Gray Seal', 'Ground Squirrel', 'Guinea Pig', 'Horse',
                                'Lesser Short-Tailed Shrew', 'Little Brown Bat', 'Man',
                                'Mouse', 'Muskshrew', 'North American Possum',
                                'Nine-Banded Armadillo', 'Owl Monkey', 'Patas Monkey',
                                'Phalanger', 'Pig', 'Rabbit', 'Rat', 'Red Fox', 'Rhesus Monkey',
                                'Rock Hyrax I', 'Rock Hyrax II', 'Sheep', 'Tenrec',
                                'Tree Hyrax', 'Tree Shrew', 'Vervet', 'Water Opossum'];

            // Create a JSON mapping the dataset species' labels to the cleaned names
            let speciesLabels = {};
            species.forEach( (d, i) => {
                speciesLabels[d] = cleanedSpecies[i];
            })

                    // Species name
                    chartArea8.selectAll("text.name")
                        .data(data)
                        .enter().append("text")
                        .attr("x", -75)
                        .attr("y", d => yScale(d.species))
                        .attr("dy", ".90em")
                        .attr("text-anchor", "middle")
                        .attr('font-family', 'arial')
                        .attr('font-size', '12px')
                        .attr('class', 'name')
                        .text(d => speciesLabels[d.species]);

        };
// =================================================================================================
// #################### End of Plot 8 -- Double bar Chart dreams vs Non Dreaming
//==================================================================================================


        d3.csv(file).then( (data) => {
            const svg1 = plot1Div.append('svg')
                            .attr('width', plotWidth)
                            .attr('height', plotHeight)
                            .attr('id', 'svg1')


            const svg9 = plot9Div.append('svg')
                            .attr('width', lollipopPlotWidth)
                            .attr('height', lollipopPlotHeight)
                            .attr('id', 'svg9')
                            .style('border', '1px solid black')
            const chartArea9 = svg9.append('g')
                                   .attr('transform', 'translate(0, 50)');


            // Remove NAs
            data = data.filter( d => (d.gestation != "NA" && d.total_sleep != "NA" && d.dreaming != "NA" && d.life_span != "NA" && d.non_dreaming != "NA"))

            // Plot 8 function
            render(data)


            // Convert strings to numbers
            data.forEach( (d) => {
		        d.gestation = Number(d.gestation);
                d.total_sleep = Number(d.total_sleep);
                d.brain_wt = Number(d.brain_wt);
                d.body_wt = Number(d.body_wt);
                d.pred = Number(d.predation);
                d.non_dreaming = Number(d.non_dreaming);
                d.dreaming = Number(d.dreaming);
	        })

            console.log(data);
            console.log(data[0].brain_wt)
            const gesRange = d3.extent( data, d => d.gestation);
            const sleepRange = d3.extent( data, d => d.total_sleep);
            const dreamRange = d3.extent( data, d => d.dreaming);
            const nondreamRange = d3.extent( data, d => d.non_dreaming);

            const maxDream = Math.max(dreamRange[1],nondreamRange[1]);

            const predRange = d3.extent( data, d => d.pred);
            console.log(gesRange);
            console.log(sleepRange);
            console.log(predRange);

            const basicXScale = d3.scaleLinear().domain([0, data.length]).range([5, plotWidth]);
            const dreamScale = d3.scaleLinear().domain([0,maxDream]).range([plotHeight - circleRadius, circleRadius]);
            const percentScale = d3.scaleLinear().domain([0,100]).range([plotHeight - circleRadius, circleRadius]);

            // let lineGen = d3.line()

            // svg10 -> final plot 3 START -------------------------------------
            // svg element for final 3rd plot
            const margin2 = {top: 20, right: 20, bottom: 20, left: 20};

            const svg10 = plot10Div.append('svg')
                            .attr('width', plotWidth)
                            .attr('height', plotHeight)
                            .style('border', '1px solid black')
            const chartArea10 = svg10.append('g')
                            .attr('transform', `translate(${margin2.left},${margin2.top})`);

            // TODO
            // let stats = d3.nest
            //     .key(data, d => d.pred)
            //     .rollup(function(d) {
            //       q1 = d3.quantile(d.map(function(g) { return d.total_sleep;}).sort(d3.ascending),.25)
            //       median = d3.quantile(d.map(function(g) { return d.total_sleep;}).sort(d3.ascending),.5)
            //       q3 = d3.quantile(d.map(function(g) { return d.total_sleep;}).sort(d3.ascending),.75)
            //       interQuantileRange = q3 - q1
            //       min = q1 - 1.5 * interQuantileRange
            //       max = q3 + 1.5 * interQuantileRange
            //       return({q1: q1, median: median, q3: q3, interQuantileRange: interQuantileRange, min: min, max: max})
            //     })
            //     .entries(data)
            //
            // // Show the X scale
            // var x = d3.scaleBand()
            //   .range([ 0, width ])
            //   .domain(["setosa", "versicolor", "virginica"])
            //   .paddingInner(1)
            //   .paddingOuter(.5)
            // chartArea10.append("g")
            //   .attr("transform", "translate(0," + height + ")")
            //   .call(d3.axisBottom(x))
            //
            // // Show the Y scale
            // var y = d3.scaleLinear()
            //   .domain([3,9])
            //   .range([height, 0])
            // chartArea10.append("g").call(d3.axisLeft(y))
            //
            // // Show the main vertical line
            // chartArea10.selectAll("vertLines")
            //            .data(statsInfo)
            //            .enter()
            //            .append("line")
            //                 .attr("x1", function(d){return(x(d.key))})
            //                 .attr("x2", function(d){return(x(d.key))})
            //                 .attr("y1", function(d){return(y(d.value.min))})
            //                 .attr("y2", function(d){return(y(d.value.max))})
            //                 .attr("stroke", "black")
            //                 .style("width", 40)
            //
            // // rectangle for the main box
            // var boxWidth = 100
            // chartArea10.selectAll("boxes")
            //            .data(statsInfo)
            //            .enter()
            //            .append("rect")
            //                 .attr("x", function(d){return(x(d.key)-boxWidth/2)})
            //                 .attr("y", function(d){return(y(d.value.q3))})
            //                 .attr("height", function(d){return(y(d.value.q1)-y(d.value.q3))})
            //                 .attr("width", boxWidth )
            //                 .attr("stroke", "black")
            //                 .style("fill", "#69b3a2")

            // svg10 -> final plot 3 END ---------------------------------------


            // svg 1
            let allPredation = data.map( d => d.pred );
            let uniquePred = [...new Set(allPredation)];
            console.log(uniquePred);

            const margin = {left: 50, right: 10, top: 10, bottom: 50}
            const padding = {bottom: 50, top: 50}
            const gesScale = d3.scaleLinear().domain(gesRange).range([50, plotWidth]);
            const sleepScale = d3.scaleLinear().domain(sleepRange).range([plotHeight - padding.bottom - margin.bottom, padding.top]);

            //["#e41a1c","#377eb8","#4daf4a","#984ea3","#ff7f00","#ffff33","#a65628","#f781bf","#999999"]
            let colors = ["green", "gold", "orange", "red" ,"black"]; // update to have red as the highest predation
            const colorScale = d3.scaleOrdinal(colors).domain([1,2,3,4,5])

            const chartArea1 = svg1.append('g')
                                   .attr('transform', `translate(${margin.left}, ${margin.top})`)

            let bottomAxis = d3.axisBottom(gesScale);
            let bottomAxisGroup = svg1.append('g')
                                      .attr('class', 'x axis')
                                      .attr('id', 'plot1-xaxis')
                                      .attr('transform', `translate(${margin.left}, ${plotHeight - margin.top - margin.bottom - 10})`)
                                      .call(bottomAxis)

            let bottomAxisText = bottomAxisGroup.append('text')
                .text('Gestation')
                .attr('x', plotWidth/2)
                .attr('y', padding.bottom - 8)
                .attr('text-align', 'middle')
                .attr('font-size', '20px')
                .attr('fill', 'black')

            let leftAxis = d3.axisLeft(sleepScale);
            let leftAxisGroup = svg1.append('g')
                                    .attr('class', 'y axis')
                                    .attr('id', 'plot1-yaxis')
                                    .attr('transform', `translate(${margin.left+20}, ${margin.top})`)
                                    .call(leftAxis)

            let leftAxisText = svg1.append('text')
                .text('Sleep')
                .attr('x', 30)
                .attr('y', plotHeight/2)
                .attr('text-align', 'middle')
                .attr('font-size', '20px')
                .attr('fill', 'black')
                .attr('transform', 'rotate(-90,30,' + plotHeight/2 + ')')
                .style('font-family', 'arial')

            // Reference: https://www.d3indepth.com/shapes/
            let symbolCreator = d3.symbol().size(100);
            let symbolTypes = ['symbolCircle', 'symbolDiamond', 'symbolSquare', 'symbolStar', 'symbolTriangle']
            let symbols = chartArea1.selectAll('path')
                                    .data(data)
                                    .join('path')
                                    .attr('id', 'svg1data')
                                    .attr('transform', d => `translate(${gesScale(d.gestation)}, ${sleepScale(d.total_sleep)})`)
                                    .attr('d', function(d) {
                                        symbolCreator.type(d3[symbolTypes[d.pred-1]]); // account for array indexing
                                        return symbolCreator();
                                    })
                                    .style('fill', d => colors[d.pred-1])


            let predation = [1, 2, 3, 4, 5];
            predation.forEach( (d, i) => {
                chartArea1.append('path')
                          .attr('transform', d => `translate(${plotWidth - 175}, ${margin.top + padding.top + 20 + i * 25})`)
                          .attr('d', function(d) {
                                        symbolCreator.type(d3[symbolTypes[i]]);
                                        return symbolCreator();
                          })
                          .style('fill', d => colors[i]) // account for predation ranging from 1 to 5

                chartArea1.append('text')
                          .attr('transform', d => `translate(${plotWidth - 160}, ${margin.top + padding.top + 24 + i * 25})`)
                          .text(predation[i])
                          .style('font-family', 'arial')
                          .attr('font-size', '14px')
            })

            // Legend header
            chartArea1.append('text')
                      .attr('transform', d => `translate(${plotWidth - 181}, ${margin.top + padding.top})`)
                      .style('font-family', 'arial')
                      .text('Predation')
                      .attr('font-size', '20px')

            // let circles = chartArea1.selectAll('circle')
            //                         .data(data)
            //                         .join('circle')
            //                         .attr('cx', d => gesScale(d.gestation))
            //                         .attr('cy', d => sleepScale(d.total_sleep))
            //                         .attr('r', circleRadius)
            //                         .attr('opacity', circleOpacity)
            //                         .attr('id', 'svg1')
            //                         .style('fill', d => colorScale(d.pred))

            // Chart 9 -- lollipop chart code adapted from the lecture code
            // Left - body
            // Right - brain

            // Title
            chartArea9.append('text')
                      .attr('class', 'lollipop-title')
                      .attr('x', lollipopPlotWidth/2)
                      .attr('y', -20)
                      .text('Mammal Body and Brain Weight Distributions')
                      .attr('text-anchor', 'middle')
                      .attr('dominant-baseline', 'middle')
                      .attr('font-size', '30px')
                      .attr('fill', 'black')
                      .attr('font-weight', 'bold')

            // Two section headers
            chartArea9.append('text')
                      .attr('class', 'lollipop-section1')
                      .attr('x', lollipopPlotWidth/2 - 50)
                      .attr('y', 10)
                      .text('Body Weight (kg)')
                      .attr('text-anchor', 'end')
                      .attr('dominant-baseline', 'middle')
                      .attr('font-size', '16px')
                      .attr('fill', 'black')

            chartArea9.append('text')
                      .attr('class', 'lollipop-section2')
                      .attr('x', lollipopPlotWidth/2 + 50)
                      .attr('y', 10)
                      .text('Brain Weight (kg)')
                      .attr('text-anchor', 'start')
                      .attr('dominant-baseline', 'middle')
                      .attr('font-size', '16px')
                      .attr('fill', 'black')

            // Figure description
            chartArea9.append('text')
                      .attr('class', 'lollipop-description')
                      .attr('x', lollipopPlotWidth/2)
                      .attr('y', lollipopPlotHeight - 70)
                      .text('This plot shows the body and brain weight distributions for a  ' +
                            '22 mammal subset of the dataset.')
                      .attr('text-anchor', 'middle')
                      .attr('dominant-baseline', 'middle')
                      .attr('font-size', '16px')
                      .attr('fill', 'black')

            // Outer rectangle
            chartArea9.append('rect')
                      .attr('x', lollipopPlotWidth/2 - 200)
                      .attr('y', 20)
                      .attr('height', lollipopPlotHeight - 105)
                      .attr('width', 400)
                      .style('fill', 'white')
                      .style('stroke', '#ccc')
                      .style('stroke-width', 2)

            // Legend
            chartArea9.append('text')
                      .attr('x', lollipopPlotWidth - 75)
                      .attr('y', 28)
                      .text('Legend')
                      .attr('text-anchor', 'middle')
                      .attr('dominant-baseline', 'middle')
                      .attr('font-size', '18px')
                      .attr('fill', 'black')
                      .attr('font-weight', 'bold')

            chartArea9.append('rect')
                      .attr('x', lollipopPlotWidth - 140)
                      .attr('y', 50)
                      .attr('height', 20)
                      .attr('width', 20)
                      .style('fill', 'green')

            chartArea9.append('text')
                      .attr('x', lollipopPlotWidth - 60)
                      .attr('y', 60)
                      .text('> Median Life Span')
                      .attr('text-anchor', 'middle')
                      .attr('dominant-baseline', 'middle')
                      .attr('font-size', '14px')
                      .attr('fill', 'black')

            chartArea9.append('rect')
                      .attr('x', lollipopPlotWidth - 140)
                      .attr('y', 80)
                      .attr('height', 20)
                      .attr('width', 20)
                      .style('fill', 'red')

            chartArea9.append('text')
                      .attr('x', lollipopPlotWidth - 60)
                      .attr('y', 92)
                      .text('< Median Life Span')
                      .attr('text-anchor', 'middle')
                      .attr('dominant-baseline', 'middle')
                      .attr('font-size', '14px')
                      .attr('fill', 'black')


            let brainSorted = data.sort( (a,b) =>  d3.ascending(a.brain_wt, b.brain_wt) );
            let data2 = brainSorted.slice(0,-10); // Remove 10 largest brain weights
            let bodySorted = data2.sort( (a,b) =>  d3.descending(a.body_wt, b.body_wt) );
            let data3 = bodySorted.slice(0, -10); // Remove 10 smallest body weights

            const brweightRange = d3.extent( data3, d => d.brain_wt);
            const boweightRange = d3.extent( data3, d => d.body_wt);
            console.log("Range");
            console.log(boweightRange);
            console.log("Range 2");
            console.log(brweightRange);

            let speciesSubset = [];
            data3.forEach( (d) => {
                speciesSubset.push(d.species);
            })

            // Log cause there are some relatively large values
            // Linear makes many of the lines extremely small
            // Tradeoff with the exponential jump near the bottom of the plot (length increase is not intuitive)
            const bodyWeightScale = d3.scaleLog().domain(boweightRange).range([lollipopPlotWidth/2, 200]);
            const brainWeightScale = d3.scaleLog().domain(brweightRange).range([lollipopPlotWidth/2, lollipopPlotWidth - 200]);

            let medianLifeSpan = d3.median(data, d => d.life_span); // use the entire dataset to calculate the median
            console.log(medianLifeSpan);
            let medianLifeSpanColors = ['red', 'green'];

            let species = [...new Set(data3.map( d => d.species ))]; // use data subset

            // Cleaned species' names to make the plot more legible
            let cleanedSpecies = ['Rat', 'Chinchilla', 'Owl Monkey', 'Rock Hyrax I', 'European Hedgehog',
                           'Tenrec', 'African Giant Pouched Rat', 'Guinea Pig', 'Phalanger',
                           'North American Possum', 'Tree Hyrax', 'Rabbit', 'Echidna',
                           'Cat', 'Nine-Banded Armadillo', 'Water Opossum', 'Rock Hyrax II',
                           'Vervet', 'Red Fox', 'Patas Monkey', 'Goat', 'Brazilian Tapir'].reverse();

            // Create a JSON mapping the dataset species' labels to the cleaned names
            let speciesLabels = {};
            species.forEach( (d, i) => {
                speciesLabels[d] = cleanedSpecies[i];
            })
            console.log(speciesLabels);

            const speciesScale = d3.scalePoint().domain(species).range([lollipopPlotHeight - 400, 20]);
            console.log(species);

            let lollipops = chartArea9.selectAll('g.lollipop').data( data3, d => d.species)
							.join('g')
							.attr('class', 'lollipop')
							.attr('transform', d => `translate(0,${speciesScale(d.species)})`);

            let lollipops2 = chartArea9.selectAll('g.lollipop2').data( data3, d => d.species)
							.join('g')
							.attr('class', 'lollipop2')
							.attr('transform', d => `translate(0,${speciesScale(d.species)})`);

            // Middle
            chartArea9.append('line')
                .attr('x1', lollipopPlotWidth/2)
                .attr('x2', lollipopPlotWidth/2)
                .attr('y1', 20)
                .attr('y2', lollipopPlotHeight - 100)
                .attr('stroke', 'black')

            // Left half: body weight
            lollipops.append('line')
                .attr('class', 'stick')
                .attr('x1', lollipopPlotWidth/2)
                .attr('x2', d => bodyWeightScale(d.body_wt))
                .attr('y1', d => speciesScale(d.species))
                .attr('y2', d => speciesScale(d.species))
                .attr('stroke', d => medianLifeSpanColors[Number(d.life_span > medianLifeSpan)]) // green if above median life span, otherwise red
                .attr('stroke-width', d => Number(d.life_span < medianLifeSpan) * 2 + 1) // thicker if red

            // Right half: brain weight
            lollipops2.append('line')
                .attr('class', 'stick')
                .attr('x1', lollipopPlotWidth/2)
                .attr('x2', d => brainWeightScale(d.brain_wt))
                .attr('y1', d => speciesScale(d.species))
                .attr('y2', d => speciesScale(d.species))
                .attr('stroke', d => medianLifeSpanColors[Number(d.life_span > medianLifeSpan)])
                .attr('stroke-width', d => Number(d.life_span < medianLifeSpan) * 2 + 1) // thicker if red

            lollipops.append('circle')
                .attr('class', 'pop')
                .attr('r', circleRadius)
                .attr('cx', d => bodyWeightScale(d.body_wt))
                .attr('cy', d => speciesScale(d.species))
                .attr('fill', d => medianLifeSpanColors[Number(d.life_span > medianLifeSpan)])

            lollipops2.append('circle')
                .attr('class', 'pop2')
                .attr('r', circleRadius)
                .attr('cx', d => brainWeightScale(d.brain_wt))
                .attr('cy', d => speciesScale(d.species))
                .attr('fill', d => medianLifeSpanColors[Number(d.life_span > medianLifeSpan)])

            // Add text
            let leftText = lollipops.append('text')
                     .attr('class', 'lollipop-text')
                     .attr('x', d => bodyWeightScale(d.body_wt) - 7)
                     .attr('y', d => speciesScale(d.species))
                     .text(d => d.body_wt)
                     .attr('text-anchor', 'end')
                     .attr('dominant-baseline', 'middle')
                     .attr('font-size', '14px')
                     .attr('fill', 'black')

            lollipops2.append('text')
                      .attr('class', 'lollipip-text')
                      .attr('x', d => brainWeightScale(d.brain_wt) + 7)
                      .attr('y', d => speciesScale(d.species))
                      .text(d => d.brain_wt)
                      .attr('text-anchor', 'start')
                      .attr('dominant-baseline', 'middle')
                      .attr('font-size', '14px')
                      .attr('fill', 'black')

            lollipops.append('text')
                     .attr('class', 'species-text')
                     .attr('x', 140)
                     .attr('y', d => speciesScale(d.species))
                     .text(d => speciesLabels[d.species]) // referened the JSON for the cleaned species' names
                     .attr('text-anchor', 'end')
                     .attr('dominant-baseline', 'middle')
                     .attr('font-size', '12px')
                     .attr('fill', 'black')


            data.forEach( (d, i) => {
                // Gestation vs. total_sleep, stratified by predation
                // chartArea1.append('circle')
                //          .attr('cx', gesScale(d.gestation))
                //          .attr('cy', sleepScale(d.total_sleep))
                //          .attr('r', circleRadius)
                //          .attr('opacity', circleOpacity)
                //          .attr('index', i)
                //          .style('fill', colorScale(d.pred))

                //


            })

        });

    </script>
</body>
</html>
