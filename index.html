<html>
<meta charset='utf-8'>
<head>
    <script src='https://d3js.org/d3.v7.min.js'></script>
    <style>
        .gridlines .domain {
            stroke: none;
        }
    </style>
</head>
<body>
    <div id='plot1'></div>
    <br>
    <div id='plot2'></div>
    <br>
    <div id='plot3'></div>
    <br>
    <div id='plot4'></div>
    <br>
    <div id='plot5'></div>
    <br>
    <div id='plot6'></div>
    <br>
    <div id='plot7'></div>
    <br>
    <div id='plot8'></div>
    <br>
    <div id='plot9'></div>

    <script>
        let plot1Div = d3.select('#plot1');
        let plot2Div = d3.select('#plot2');
        let plot3Div = d3.select('#plot3');
        let plot4Div = d3.select('#plot4');
        let plot5Div = d3.select('#plot5');
        let plot6Div = d3.select('#plot6');
        let plot7Div = d3.select('#plot7');
        let plot8Div = d3.select('#plot8');
        let plot9Div = d3.select('#plot9');
        let file = 'mammals.csv';
        let plotWidth = 600;
        let plotHeight = 600;
        let circleRadius = 5;
        let circleOpacity = 0.7;

        d3.csv(file).then( (data) => {
            const svg1 = plot1Div.append('svg')
                            .attr('width', plotWidth)
                            .attr('height', plotHeight)
                            .attr('id', 'svg1')

            const svg2 = plot2Div.append('svg')
                            .attr('width', plotWidth)
                            .attr('height', plotHeight)
                            .style('border', '1px solid black')
            const chartArea2 = svg2.append('g');

            const svg3 = plot3Div.append('svg')
                            .attr('width', plotWidth)
                            .attr('height', plotHeight)
                            .style('border', '1px solid black')
            const brainSleep = svg3.append('g');

            const svg4 = plot4Div.append('svg')
                            .attr('width', plotWidth)
                            .attr('height', plotHeight)
                            .style('border', '1px solid black')
            const brainDream = svg4.append('g');

            const svg5 = plot5Div.append('svg')
                            .attr('width', plotWidth)
                            .attr('height', plotHeight)
                            .style('border', '1px solid black')
            const chartArea5 = svg5.append('g');

            const svg6 = plot6Div.append('svg')
                            .attr('width', plotWidth)
                            .attr('height', plotHeight)
                            .style('border', '1px solid black')
            const chartArea6 = svg6.append('g');

            const svg7 = plot7Div.append('svg')
                            .attr('width', plotWidth)
                            .attr('height', plotHeight)
                            .style('border', '1px solid black')
            const chartArea7 = svg7.append('g');

            const svg8 = plot8Div.append('svg')
                            .attr('width', plotWidth)
                            .attr('height', plotHeight)
                            .style('border', '1px solid black')
            const chartArea8 = svg8.append('g');

            const svg9 = plot9Div.append('svg')
                            .attr('width', plotWidth)
                            .attr('height', plotHeight)
                            .attr('id', 'svg9')
            const chartArea9 = svg9.append('g');


            // Remove NAs
            data = data.filter( d => (d.gestation != "NA" && d.total_sleep != "NA" && d.dreaming != "NA" && d.life_span != "NA"))

            // Convert strings to numbers
            data.forEach( (d) => {
		        d.gestation = Number(d.gestation);
                d.total_sleep = Number(d.total_sleep);
                d.brain_wt = Number(d.brain_wt);
                d.body_wt = Number(d.body_wt);
                d.pred = Number(d.predation);
                d.non_dreaming = Number(d.non_dreaming);
                d.dreaming = Number(d.dreaming);
	        })

            console.log(data);
            console.log(data[0].brain_wt)
            const gesRange = d3.extent( data, d => d.gestation);
            const sleepRange = d3.extent( data, d => d.total_sleep);
            const brweightRange = d3.extent( data, d => d.brain_wt);
            const boweightRange = d3.extent( data, d => d.body_wt);
            const dreamRange = d3.extent( data, d => d.dreaming);
            const nondreamRange = d3.extent( data, d => d.non_dreaming);

            const maxDream = Math.max(dreamRange[1],nondreamRange[1]);

            const predRange = d3.extent( data, d => d.pred);
            console.log(gesRange);
            console.log(sleepRange);
            console.log(brweightRange);
            console.log(boweightRange);
            console.log(predRange);


            const basicXScale = d3.scaleLinear().domain([0, data.length]).range([0, plotWidth]);
            const dreamScale = d3.scaleLinear().domain([0,maxDream]).range([plotHeight - circleRadius, circleRadius]);
            const percentScale = d3.scaleLinear().domain([0,100]).range([plotHeight - circleRadius, circleRadius]);

            // let lineGen = d3.line()


            // svg 1
            let allPredation = data.map( d => d.pred );
            let uniquePred = [...new Set(allPredation)];
            console.log(uniquePred);

            const margin = {left: 50, right: 10, top: 10, bottom: 50}
            const padding = {bottom: 50, top: 50}
            const gesScale = d3.scaleLinear().domain(gesRange).range([0, plotWidth]);
            const sleepScale = d3.scaleLinear().domain(sleepRange).range([plotHeight - padding.bottom - margin.bottom, padding.top]);
                
            //["#e41a1c","#377eb8","#4daf4a","#984ea3","#ff7f00","#ffff33","#a65628","#f781bf","#999999"]
            let colors = ["#377eb8", "#984ea3", "#4daf4a", "#ff7f00" ,"#e41a1c"]; // update to have red as the highest predation
            const colorScale = d3.scaleOrdinal().domain(predRange).range(colors);

            const chartArea1 = svg1.append('g')
                                   .attr('transform', `translate(${margin.left}, ${margin.top})`)
            
            let bottomAxis = d3.axisBottom(gesScale);
            let bottomAxisGroup = svg1.append('g')
                                      .attr('class', 'x axis')
                                      .attr('id', 'plot1-xaxis')
                                      .attr('transform', `translate(${margin.left}, ${plotHeight - margin.top - margin.bottom - 10})`)
                                      .call(bottomAxis)
            
            let bottomAxisText = bottomAxisGroup.append('text')
                .text('Gestation')
                .attr('x', plotWidth/2)
                .attr('y', padding.bottom - 10)
                .attr('text-align', 'middle')
                .attr('font-size', '16px')
                .attr('fill', 'black')
            
            let leftAxis = d3.axisLeft(sleepScale);
            let leftAxisGroup = svg1.append('g')
                                    .attr('class', 'y axis')
                                    .attr('id', 'plot1-yaxis')
                                    .attr('transform', `translate(${margin.left - 10}, ${margin.top})`)
                                    .call(leftAxis)
            
            // Reference: https://www.d3indepth.com/shapes/
            let symbolCreator = d3.symbol().size(100);
            let symbolTypes = ['symbolCircle', 'symbolDiamond', 'symbolSquare', 'symbolStar', 'symbolTriangle']
            let symbols = chartArea1.selectAll('path')
                                    .data(data)
                                    .join('path')
                                    .attr('id', 'svg1data')
                                    .attr('transform', d => `translate(${gesScale(d.gestation)}, ${sleepScale(d.total_sleep)})`)
                                    .attr('d', function(d) { 
                                        symbolCreator.type(d3[symbolTypes[d.pred-1]]); // account for array indexing
                                        return symbolCreator();
                                    })
                                    .style('fill', d => colorScale(d.pred))

            let predation = [1, 2, 3, 4, 5];
            predation.forEach( (d, i) => {
                chartArea1.append('path')
                          .attr('transform', d => `translate(${plotWidth - 175}, ${margin.top + padding.top + 20 + i * 25})`)
                          .attr('d', function(d) { 
                                        symbolCreator.type(d3[symbolTypes[i]]);
                                        return symbolCreator();
                          })
                          .style('fill', d => colorScale(i + 1)) // account for predation ranging from 1 to 5
                chartArea1.append('text')
                          .attr('transform', d => `translate(${plotWidth - 160}, ${margin.top + padding.top + 24 + i * 25})`)
                          .text(predation[i])
            })

            // Legend header
            chartArea1.append('text')
                      .attr('transform', d => `translate(${plotWidth - 195}, ${margin.top + padding.top})`)
                      .text('Predation')

            // let circles = chartArea1.selectAll('circle')
            //                         .data(data)
            //                         .join('circle')
            //                         .attr('cx', d => gesScale(d.gestation))
            //                         .attr('cy', d => sleepScale(d.total_sleep))
            //                         .attr('r', circleRadius)
            //                         .attr('opacity', circleOpacity)
            //                         .attr('id', 'svg1')
            //                         .style('fill', d => colorScale(d.pred))

            // Chart 9
            console.log("Range");
            console.log(boweightRange);
            console.log("Range 2");
            console.log(brweightRange);
            const bodyWeightScale = d3.scaleLog().domain(boweightRange).range([0, plotWidth/2]);
            const brainWeightScale = d3.scaleLog().domain(brweightRange).range([plotWidth/2, plotWidth]);
            
            let medianLifeSpan = d3.median(data, d => d.life_span);
            console.log(medianLifeSpan);
            let medianLifeSpanColors = ['red', 'green'];

            let species = [...new Set(data.map( d => d.species ))];
            const speciesScale = d3.scalePoint().domain(species).range([plotHeight, 0]);
            console.log(species);

            let lollipops = chartArea9.selectAll('g.lollipop').data( data, d => d.species)
							.join('g')
							.attr('class', 'lollipop')
							.attr('transform', d => `translate(0,${speciesScale(d.species)})`);

            let lollipops2 = chartArea9.selectAll('g.lollipop2').data( data, d => d.species)
							.join('g')
							.attr('class', 'lollipop2')
							.attr('transform', d => `translate(0,${speciesScale(d.species)})`);
            
            // Middle
            chartArea9.append('line')
                .attr('x1', plotWidth/2)
                .attr('x2', plotWidth/2)
                .attr('y1', 0)
                .attr('y2', plotHeight)
                .attr('stroke', 'black')
            
            // Left half: body weight
            lollipops.append('line')
                .attr('class', 'stick')
                .attr('x1', plotWidth/2)
                .attr('x2', d => bodyWeightScale(d.body_wt))
                .attr('y1', d => speciesScale(d.species))
                .attr('y2', d => speciesScale(d.species))
                .attr('stroke', d => medianLifeSpanColors[Number(d.life_span > medianLifeSpan)]) // green if above median life span, otherwise red
            
            // Right half: brain weight
            lollipops2.append('line')
                .attr('class', 'stick')
                .attr('x1', plotWidth/2)
                .attr('x2', d => brainWeightScale(d.brain_wt))
                .attr('y1', d => speciesScale(d.species))
                .attr('y2', d => speciesScale(d.species))
                .attr('stroke', d => medianLifeSpanColors[Number(d.life_span > medianLifeSpan)])
            
            lollipops.append('circle')
                .attr('class', 'pop')
                .attr('r', circleRadius)
                .attr('cx', d => bodyWeightScale(d.body_wt))
                .attr('cy', d => speciesScale(d.species))
                .attr('fill', d => medianLifeSpanColors[Number(d.life_span > medianLifeSpan)])
            
            lollipops2.append('circle')
                .attr('class', 'pop2')
                .attr('r', circleRadius)
                .attr('cx', d => brainWeightScale(d.brain_wt))
                .attr('cy', d => speciesScale(d.species))
                .attr('fill', d => medianLifeSpanColors[Number(d.life_span > medianLifeSpan)])

            data.forEach( (d, i) => {
                // Gestation vs. total_sleep, stratified by predation
                // chartArea1.append('circle')
                //          .attr('cx', gesScale(d.gestation))
                //          .attr('cy', sleepScale(d.total_sleep))
                //          .attr('r', circleRadius)
                //          .attr('opacity', circleOpacity)
                //          .attr('index', i)
                //          .style('fill', colorScale(d.pred))

                //
                chartArea2.append('rect')
                          .attr('x', basicXScale(i))
                          .attr('y', plotHeight - gesScale(d.gestation))
                          .attr('height', gesScale(d.gestation))
                          .attr('width', plotWidth/data.length)
                          .style('fill', colorScale(d.pred))

                if (d.brain_wt < 700) {
                    brainSleep.append('circle')
                            .attr('cx', brainWeightScale(d.brain_wt))
                            .attr('cy', sleepScale(d.total_sleep))
                            .attr('r', circleRadius)
                            .attr('index', i)
                            .style('fill', 'indigo')
                }

                brainDream.append('circle')
                            .attr('cx', brainWeightScale(d.brain_wt))
                            .attr('cy', dreamScale(d.dreaming))
                            .attr('r', circleRadius)
                            .attr('index', i)
                            .style('fill', 'orange')

                brainDream.append('circle')
                            .attr('cx', brainWeightScale(d.brain_wt))
                            .attr('cy', dreamScale(d.non_dreaming))
                            .attr('r', circleRadius)
                            .attr('index', i)
                            .style('fill', 'indigo')

                // brain weight vs the percentage of time a mammal spends sleeping in their life.
                // curious if mammals that have a certain brain weight will spend more of their life sleeping
                let percentSleepLife = ((365*d.life_span*d.total_sleep)/(d.life_span*24*365))*100;
                chartArea5.append('circle')
                        .attr('cx', brainWeightScale(d.brain_wt))
                        .attr('cy', percentScale(percentSleepLife))
                        .attr('r', circleRadius)
                        .attr('opacity', 0.4)
                        .attr('index', i)
                        .style('fill', 'blue')

                // weight vs the percentage of time a mammal spends dreaming while they sleep
                let percentDreamSleep = (d.dreaming/d.total_sleep)*100;
                chartArea6.append('circle')
                        .attr('cx', brainWeightScale(d.brain_wt))
                        .attr('cy', percentScale(percentDreamSleep))
                        .attr('r', circleRadius)
                        .attr('opacity', 0.4)
                        .attr('index', i)
                        .style('fill', 'purple')

                chartArea7.append('circle')
                        .attr('cx', bodyWeightScale(d.body_wt))
                        .attr('cy', sleepScale(d.total_sleep))
                        .attr('r', circleRadius)
                        .attr('opacity', 0.4)
                        .attr('index', i)
                        .style('fill', colorScale(d.pred))

                chartArea8.append('rect')
                        .attr('x', gesScale(d.gestation))
                        .attr('y', plotHeight - bodyWeightScale(d.body_wt))
                        .attr('height', bodyWeightScale(d.body_wt))
                        .attr('width', plotWidth/data.length)
                        .style('fill', colorScale(d.pred))
            })

        });

    </script>
</body>
</html>
